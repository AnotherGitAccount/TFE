
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_NANO_SoC_GHRD(

    //////////// CLOCK //////////
    input               FPGA_CLK1_50,
    input               FPGA_CLK2_50,
    input               FPGA_CLK3_50,

    //////////// HDMI //////////
    inout               HDMI_I2C_SCL,
    inout               HDMI_I2C_SDA,
    inout               HDMI_I2S,
    inout               HDMI_LRCLK,
    inout               HDMI_MCLK,
    inout               HDMI_SCLK,
    output              HDMI_TX_CLK,
    output   [23: 0]    HDMI_TX_D,
    output              HDMI_TX_DE,
    output              HDMI_TX_HS,
    input               HDMI_TX_INT,
    output              HDMI_TX_VS,

    //////////// HPS //////////
    inout               HPS_CONV_USB_N,
    output   [14: 0]    HPS_DDR3_ADDR,
    output   [ 2: 0]    HPS_DDR3_BA,
    output              HPS_DDR3_CAS_N,
    output              HPS_DDR3_CK_N,
    output              HPS_DDR3_CK_P,
    output              HPS_DDR3_CKE,
    output              HPS_DDR3_CS_N,
    output   [ 3: 0]    HPS_DDR3_DM,
    inout    [31: 0]    HPS_DDR3_DQ,
    inout    [ 3: 0]    HPS_DDR3_DQS_N,
    inout    [ 3: 0]    HPS_DDR3_DQS_P,
    output              HPS_DDR3_ODT,
    output              HPS_DDR3_RAS_N,
    output              HPS_DDR3_RESET_N,
    input               HPS_DDR3_RZQ,
    output              HPS_DDR3_WE_N,
    output              HPS_ENET_GTX_CLK,
    inout               HPS_ENET_INT_N,
    output              HPS_ENET_MDC,
    inout               HPS_ENET_MDIO,
    input               HPS_ENET_RX_CLK,
    input    [ 3: 0]    HPS_ENET_RX_DATA,
    input               HPS_ENET_RX_DV,
    output   [ 3: 0]    HPS_ENET_TX_DATA,
    output              HPS_ENET_TX_EN,
    inout               HPS_GSENSOR_INT,
    inout               HPS_I2C0_SCLK,
    inout               HPS_I2C0_SDAT,
    inout               HPS_I2C1_SCLK,
    inout               HPS_I2C1_SDAT,
    inout               HPS_KEY,
    inout               HPS_LED,
    inout               HPS_LTC_GPIO,
    output              HPS_SD_CLK,
    inout               HPS_SD_CMD,
    inout    [ 3: 0]    HPS_SD_DATA,
    output              HPS_SPIM_CLK,
    input               HPS_SPIM_MISO,
    output              HPS_SPIM_MOSI,
    inout               HPS_SPIM_SS,
    input               HPS_UART_RX,
    output              HPS_UART_TX,
    input               HPS_USB_CLKOUT,
    inout    [ 7: 0]    HPS_USB_DATA,
    input               HPS_USB_DIR,
    input               HPS_USB_NXT,
    output              HPS_USB_STP,

    //////////// KEY //////////
    input    [ 1: 0]    KEY,

    //////////// LED //////////
    output   [ 7: 0]    LED,

    //////////// SW //////////
    input    [ 3: 0]    SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
wire hps_fpga_reset_n;
wire     [1: 0]     fpga_debounced_buttons;
wire     [2: 0]     hps_reset_req;
wire                hps_cold_reset;
wire                hps_warm_reset;
wire                hps_debug_reset;
wire     [27: 0]    stm_hw_events;
wire                fpga_clk_50;
// connection of internal logics
assign fpga_clk_50 = FPGA_CLK1_50;
// Machine
wire [7:0] ctrl;
wire alive;
// DMAs
wire        im_avbus_acknowledge;         
wire        im_avbus_irq;                 
wire [16:0] im_avbus_address;                     
wire        im_avbus_bus_enable;                   
wire [3:0]  im_avbus_byte_enable;                  
wire        im_avbus_rw;                           
wire [31:0] im_avbus_write_data;                   
wire [31:0] im_avbus_read_data;    

//=======================================================
//  Structural coding
//=======================================================
soc_system u0(
               //Clock&Reset
               .clk_clk(FPGA_CLK1_50),                                      //                            clk.clk
               .reset_reset_n(hps_fpga_reset_n),                            //                          reset.reset_n
               //HPS ddr3
               .memory_mem_a(HPS_DDR3_ADDR),                                //                         memory.mem_a
               .memory_mem_ba(HPS_DDR3_BA),                                 //                               .mem_ba
               .memory_mem_ck(HPS_DDR3_CK_P),                               //                               .mem_ck
               .memory_mem_ck_n(HPS_DDR3_CK_N),                             //                               .mem_ck_n
               .memory_mem_cke(HPS_DDR3_CKE),                               //                               .mem_cke
               .memory_mem_cs_n(HPS_DDR3_CS_N),                             //                               .mem_cs_n
               .memory_mem_ras_n(HPS_DDR3_RAS_N),                           //                               .mem_ras_n
               .memory_mem_cas_n(HPS_DDR3_CAS_N),                           //                               .mem_cas_n
               .memory_mem_we_n(HPS_DDR3_WE_N),                             //                               .mem_we_n
               .memory_mem_reset_n(HPS_DDR3_RESET_N),                       //                               .mem_reset_n
               .memory_mem_dq(HPS_DDR3_DQ),                                 //                               .mem_dq
               .memory_mem_dqs(HPS_DDR3_DQS_P),                             //                               .mem_dqs
               .memory_mem_dqs_n(HPS_DDR3_DQS_N),                           //                               .mem_dqs_n
               .memory_mem_odt(HPS_DDR3_ODT),                               //                               .mem_odt
               .memory_mem_dm(HPS_DDR3_DM),                                 //                               .mem_dm
               .memory_oct_rzqin(HPS_DDR3_RZQ),                             //                               .oct_rzqin
               //HPS ethernet
               .hps_0_hps_io_hps_io_emac1_inst_TX_CLK(HPS_ENET_GTX_CLK),    //                   hps_0_hps_io.hps_io_emac1_inst_TX_CLK
               .hps_0_hps_io_hps_io_emac1_inst_TXD0(HPS_ENET_TX_DATA[0]),   //                               .hps_io_emac1_inst_TXD0
               .hps_0_hps_io_hps_io_emac1_inst_TXD1(HPS_ENET_TX_DATA[1]),   //                               .hps_io_emac1_inst_TXD1
               .hps_0_hps_io_hps_io_emac1_inst_TXD2(HPS_ENET_TX_DATA[2]),   //                               .hps_io_emac1_inst_TXD2
               .hps_0_hps_io_hps_io_emac1_inst_TXD3(HPS_ENET_TX_DATA[3]),   //                               .hps_io_emac1_inst_TXD3
               .hps_0_hps_io_hps_io_emac1_inst_RXD0(HPS_ENET_RX_DATA[0]),   //                               .hps_io_emac1_inst_RXD0
               .hps_0_hps_io_hps_io_emac1_inst_MDIO(HPS_ENET_MDIO),         //                               .hps_io_emac1_inst_MDIO
               .hps_0_hps_io_hps_io_emac1_inst_MDC(HPS_ENET_MDC),           //                               .hps_io_emac1_inst_MDC
               .hps_0_hps_io_hps_io_emac1_inst_RX_CTL(HPS_ENET_RX_DV),      //                               .hps_io_emac1_inst_RX_CTL
               .hps_0_hps_io_hps_io_emac1_inst_TX_CTL(HPS_ENET_TX_EN),      //                               .hps_io_emac1_inst_TX_CTL
               .hps_0_hps_io_hps_io_emac1_inst_RX_CLK(HPS_ENET_RX_CLK),     //                               .hps_io_emac1_inst_RX_CLK
               .hps_0_hps_io_hps_io_emac1_inst_RXD1(HPS_ENET_RX_DATA[1]),   //                               .hps_io_emac1_inst_RXD1
               .hps_0_hps_io_hps_io_emac1_inst_RXD2(HPS_ENET_RX_DATA[2]),   //                               .hps_io_emac1_inst_RXD2
               .hps_0_hps_io_hps_io_emac1_inst_RXD3(HPS_ENET_RX_DATA[3]),   //                               .hps_io_emac1_inst_RXD3
               //HPS SD card
               .hps_0_hps_io_hps_io_sdio_inst_CMD(HPS_SD_CMD),              //                               .hps_io_sdio_inst_CMD
               .hps_0_hps_io_hps_io_sdio_inst_D0(HPS_SD_DATA[0]),           //                               .hps_io_sdio_inst_D0
               .hps_0_hps_io_hps_io_sdio_inst_D1(HPS_SD_DATA[1]),           //                               .hps_io_sdio_inst_D1
               .hps_0_hps_io_hps_io_sdio_inst_CLK(HPS_SD_CLK),              //                               .hps_io_sdio_inst_CLK
               .hps_0_hps_io_hps_io_sdio_inst_D2(HPS_SD_DATA[2]),           //                               .hps_io_sdio_inst_D2
               .hps_0_hps_io_hps_io_sdio_inst_D3(HPS_SD_DATA[3]),           //                               .hps_io_sdio_inst_D3
               //HPS USB
               .hps_0_hps_io_hps_io_usb1_inst_D0(HPS_USB_DATA[0]),          //                               .hps_io_usb1_inst_D0
               .hps_0_hps_io_hps_io_usb1_inst_D1(HPS_USB_DATA[1]),          //                               .hps_io_usb1_inst_D1
               .hps_0_hps_io_hps_io_usb1_inst_D2(HPS_USB_DATA[2]),          //                               .hps_io_usb1_inst_D2
               .hps_0_hps_io_hps_io_usb1_inst_D3(HPS_USB_DATA[3]),          //                               .hps_io_usb1_inst_D3
               .hps_0_hps_io_hps_io_usb1_inst_D4(HPS_USB_DATA[4]),          //                               .hps_io_usb1_inst_D4
               .hps_0_hps_io_hps_io_usb1_inst_D5(HPS_USB_DATA[5]),          //                               .hps_io_usb1_inst_D5
               .hps_0_hps_io_hps_io_usb1_inst_D6(HPS_USB_DATA[6]),          //                               .hps_io_usb1_inst_D6
               .hps_0_hps_io_hps_io_usb1_inst_D7(HPS_USB_DATA[7]),          //                               .hps_io_usb1_inst_D7
               .hps_0_hps_io_hps_io_usb1_inst_CLK(HPS_USB_CLKOUT),          //                               .hps_io_usb1_inst_CLK
               .hps_0_hps_io_hps_io_usb1_inst_STP(HPS_USB_STP),             //                               .hps_io_usb1_inst_STP
               .hps_0_hps_io_hps_io_usb1_inst_DIR(HPS_USB_DIR),             //                               .hps_io_usb1_inst_DIR
               .hps_0_hps_io_hps_io_usb1_inst_NXT(HPS_USB_NXT),             //                               .hps_io_usb1_inst_NXT
               //HPS SPI
               .hps_0_hps_io_hps_io_spim1_inst_CLK(HPS_SPIM_CLK),           //                               .hps_io_spim1_inst_CLK
               .hps_0_hps_io_hps_io_spim1_inst_MOSI(HPS_SPIM_MOSI),         //                               .hps_io_spim1_inst_MOSI
               .hps_0_hps_io_hps_io_spim1_inst_MISO(HPS_SPIM_MISO),         //                               .hps_io_spim1_inst_MISO
               .hps_0_hps_io_hps_io_spim1_inst_SS0(HPS_SPIM_SS),            //                               .hps_io_spim1_inst_SS0
               //HPS UART
               .hps_0_hps_io_hps_io_uart0_inst_RX(HPS_UART_RX),             //                               .hps_io_uart0_inst_RX
               .hps_0_hps_io_hps_io_uart0_inst_TX(HPS_UART_TX),             //                               .hps_io_uart0_inst_TX
               //HPS I2C1
               .hps_0_hps_io_hps_io_i2c0_inst_SDA(HPS_I2C0_SDAT),           //                               .hps_io_i2c0_inst_SDA
               .hps_0_hps_io_hps_io_i2c0_inst_SCL(HPS_I2C0_SCLK),           //                               .hps_io_i2c0_inst_SCL
               //HPS I2C2
               .hps_0_hps_io_hps_io_i2c1_inst_SDA(HPS_I2C1_SDAT),           //                               .hps_io_i2c1_inst_SDA
               .hps_0_hps_io_hps_io_i2c1_inst_SCL(HPS_I2C1_SCLK),           //                               .hps_io_i2c1_inst_SCL
               //GPIO
               .hps_0_hps_io_hps_io_gpio_inst_GPIO09(HPS_CONV_USB_N),       //                               .hps_io_gpio_inst_GPIO09
               .hps_0_hps_io_hps_io_gpio_inst_GPIO35(HPS_ENET_INT_N),       //                               .hps_io_gpio_inst_GPIO35
               .hps_0_hps_io_hps_io_gpio_inst_GPIO40(HPS_LTC_GPIO),         //                               .hps_io_gpio_inst_GPIO40
               .hps_0_hps_io_hps_io_gpio_inst_GPIO53(HPS_LED),              //                               .hps_io_gpio_inst_GPIO53
               .hps_0_hps_io_hps_io_gpio_inst_GPIO54(HPS_KEY),              //                               .hps_io_gpio_inst_GPIO54
               .hps_0_hps_io_hps_io_gpio_inst_GPIO61(HPS_GSENSOR_INT),      //                               .hps_io_gpio_inst_GPIO61

               .hps_0_h2f_reset_reset_n(hps_fpga_reset_n),                  //                hps_0_h2f_reset.reset_n
               .hps_0_f2h_cold_reset_req_reset_n(~hps_cold_reset),          //       hps_0_f2h_cold_reset_req.reset_n
               .hps_0_f2h_debug_reset_req_reset_n(~hps_debug_reset),        //      hps_0_f2h_debug_reset_req.reset_n
               .hps_0_f2h_warm_reset_req_reset_n(~hps_warm_reset),          //       hps_0_f2h_warm_reset_req.reset_n
					// Programmer
					.im_avbus_acknowledge(im_avbus_acknowledge),                 //                  im_avbus.acknowledge
		         .im_avbus_irq(im_avbus_irq),                                 //                          .irq
		         .im_avbus_address(im_avbus_address),                         //                          .address
					.im_avbus_bus_enable(im_avbus_bus_enable),                   //                          .bus_enable
					.im_avbus_byte_enable(im_avbus_byte_enable),                 //                          .byte_enable
					.im_avbus_rw(im_avbus_rw),                                   //                          .rw
					.im_avbus_write_data(im_avbus_write_data),                   //                          .write_data
					.im_avbus_read_data(im_avbus_read_data),                     //                          .read_data
					// Ctrl
					.ctrl_export(ctrl)
           );

//assign LED[7:0] = data[7:0];
			  
// Debounce logic to clean out glitches within 1ms
debounce debounce_inst(
             .clk(fpga_clk_50),
             .reset_n(hps_fpga_reset_n),
             .data_in(KEY),
             .data_out(fpga_debounced_buttons)
         );
defparam debounce_inst.WIDTH = 2;
defparam debounce_inst.POLARITY = "LOW";
defparam debounce_inst.TIMEOUT = 50000;               // at 50Mhz this is a debounce time of 1ms
defparam debounce_inst.TIMEOUT_WIDTH = 16;            // ceil(log2(TIMEOUT))

// Source/Probe megawizard instance
hps_reset hps_reset_inst(
              .source_clk(fpga_clk_50),
              .source(hps_reset_req)
          );

altera_edge_detector pulse_cold_reset(
                         .clk(fpga_clk_50),
                         .rst_n(hps_fpga_reset_n),
                         .signal_in(hps_reset_req[0]),
                         .pulse_out(hps_cold_reset)
                     );
defparam pulse_cold_reset.PULSE_EXT = 6;
defparam pulse_cold_reset.EDGE_TYPE = 1;
defparam pulse_cold_reset.IGNORE_RST_WHILE_BUSY = 1;

altera_edge_detector pulse_warm_reset(
                         .clk(fpga_clk_50),
                         .rst_n(hps_fpga_reset_n),
                         .signal_in(hps_reset_req[1]),
                         .pulse_out(hps_warm_reset)
                     );
defparam pulse_warm_reset.PULSE_EXT = 2;
defparam pulse_warm_reset.EDGE_TYPE = 1;
defparam pulse_warm_reset.IGNORE_RST_WHILE_BUSY = 1;

altera_edge_detector pulse_debug_reset(
                         .clk(fpga_clk_50),
                         .rst_n(hps_fpga_reset_n),
                         .signal_in(hps_reset_req[2]),
                         .pulse_out(hps_debug_reset)
                     );
defparam pulse_debug_reset.PULSE_EXT = 32;
defparam pulse_debug_reset.EDGE_TYPE = 1;
defparam pulse_debug_reset.IGNORE_RST_WHILE_BUSY = 1;

/**
*
*		MACHINE DESCRIPTION
*
**/

// CLK

wire clk;
wire [6:0] machine_clk;
/*reg [31:0] cnt;
reg clk_r;

always @(posedge(FPGA_CLK1_50)) begin
	cnt <= cnt + 32'b1;
	if(cnt == 32'd25000000) begin 
		if(clk_r == 1'b0) begin
			clk_r <= 1'b1;
		end else begin
			clk_r <= 1'b0;
		end 
		cnt <= 32'b0;
	end
end */

assign clk = FPGA_CLK1_50;

clock_controller cc(
	clk,
	machine_clk,
	ctrl,
	alive	
);

// CONTROL LOGIC

wire [5:0]  cl_addr;
wire [11:0] cl_data;

control_logic clogic(
	.address(cl_addr),
	.clock(clk),
	.clk_en(machine_clk[1]),
	.q(cl_data)
);

// CONTROL SIGNALS

wire [1:0] pcsel;
wire       ra2sel;
wire       wr;
wire [1:0] wdsel;
wire       bsel;
wire       werf;
wire [3:0] alufn;

assign pcsel  = cl_data[1:0];
assign ra2sel = cl_data[2];
assign wr     = cl_data[3];
assign wdsel  = cl_data[5:4];
assign bsel   = cl_data[6];
assign werf   = cl_data[7];
assign alufn  = cl_data[11:8];

// PROGRAM COUNTER

wire [31:0] pc_loop;
wire [31:0] pc_addr;

program_counter pc(
	.clk(clk),
	.rst(~alive),
	.clk_en(machine_clk[6]),
	.pcsel(pcsel),
	.pc_in(pc_loop),
	.offset(lit),
	.address(pc_addr),
	.pc_out(pc_loop)
);

// INSTRUCTION MEMORY DMA

wire [14:0] im_dma_address; 
wire [31:0] im_dma_data;
wire 			im_dma_wren;

im_dma instruction_dma(
	.clk(clk),
	
	.bus_acknowledge(im_avbus_acknowledge),                  
	.bus_irq(im_avbus_irq),                          
	.bus_address(im_avbus_address),                     
	.bus_bus_enable(im_avbus_bus_enable),                   
	.bus_byte_enable(im_avbus_byte_enable),                  
	.bus_rw(im_avbus_rw),                          
	.bus_write_data(im_avbus_write_data),                   
	.bus_read_data(im_avbus_read_data),
	
	.dma_en(~alive),
	.address(im_dma_address),
	.data(im_dma_data),
	.wren(im_dma_wren)
);

// INSTRUCTION MEMORY

wire im_clk_en;
wire [31:0] im_data; // might change..
wire [12:0] im_address;
wire 			im_wren;

assign im_clk_en = machine_clk[0] || ~alive; // tf = transaction flag
assign im_address = (alive == 1'b1) ? pc_loop[12:0] : im_dma_address[12:0];  // TODO Same sizes for all address words...
assign im_wren = (alive == 1'b1) ? 1'b0 : im_dma_wren;

ram instruction_memory(
	.clock(clk),
	.clk_en(im_clk_en),
	.address(im_address),
	.data(im_dma_data),
	.wren(im_wren),
	.q(im_data)
);
							 
// OPERATION SIGNALS

wire [4:0]  ra;
wire [4:0]  rb;
wire [4:0]  rc;
wire [15:0] lit;
wire [5:0]  opcode;

assign lit     = im_data[15:0];
assign rb      = im_data[15:11];
assign ra      = im_data[20:16];
assign rc      = im_data[25:21];
assign opcode  = im_data[31:26];
assign cl_addr = opcode;

// REGISTER FILE

wire [4:0]  rf_addr_r2;
wire [31:0] rf_data_w;
wire [31:0] rf_data_r1;
wire [31:0] rf_data_r2;
wire        rf_nz;

assign rf_addr_r2 = (ra2sel == 1'b0) ? rb : rc;

assign pc_addr = rf_data_r1;

register_file regfile(
	.CLK(clk),
	.CLK_EN({machine_clk[5], machine_clk[2]}),
	.READ_ADDRESS1(ra),
	.READ_ADDRESS2(rf_addr_r2),
	.WRITE_ADDRESS(rc),
	.WRITE_ENABLE(werf),
	.WRITE_DATA(rf_data_w),
	.READ_DATA1(rf_data_r1),
	.READ_DATA2(rf_data_r2),
	.leds(LED[6:0])
);

// ALU

wire [31:0] alu_data_b;
wire [31:0] alu_res;

assign alu_data_b = (bsel == 1'b0) ? {16'b0, lit} : rf_data_r2;

alu the_alu(
	.clk(clk),
	.clk_en(machine_clk[3]),
	.data_a(rf_data_r1),
	.data_b(alu_data_b),
	.alufn(alufn),
	.res(alu_res)
);

// DATA MEMORY

wire [31:0] dm_data_r;

ram data_memory(
	.clock(clk),
	.clk_en(machine_clk[4]),
	.address(alu_res),
	.data(rf_data_r2),
	.wren(wr),
	.q(dm_data_r)
);

assign rf_data_w = (wdsel[1] == 1'b0) ? ((wdsel[0] == 1'b0) ? pc_loop : alu_res) : dm_data_r;

// GPU
gpu igpu(
	.clk(clk),
	.pclk(HDMI_TX_CLK),
	.clk_en(machine_clk),
	.wren(wr),
	.data(rf_data_r2),
	.address(alu_res),
	.red(HDMI_TX_D[23:20]),
	.green(HDMI_TX_D[15:12]),
	.blue(HDMI_TX_D[7:4]),
	.sync_h(HDMI_TX_HS),
	.sync_v(HDMI_TX_VS),
	.disp_en(HDMI_TX_DE)  
);

assign HDMI_TX_D[19:16] = 4'b0;
assign HDMI_TX_D[11:8]  = 4'b0;
assign HDMI_TX_D[3:0]   = 4'b0;

I2C_HDMI_Config u_I2C_HDMI_Config (
	.iCLK(clk),
	.iRST_N(1'b1),
	.I2C_SCLK(HDMI_I2C_SCL),
	.I2C_SDAT(HDMI_I2C_SDA),
	.HDMI_TX_INT(HDMI_TX_INT)
);
	
// LEDS

assign LED[7]   = alive;

endmodule
