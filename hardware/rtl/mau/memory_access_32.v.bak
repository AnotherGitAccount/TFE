`define ST_IDDLE 2'b00
`define ST_READ  2'b01
`define ST_WRITE 2'b10
`define ST_NONE  2'b11

module memory_access_32(
	clk,
	bus_acknowledge,                  
	bus_irq,                          
	bus_address,                     
	bus_bus_enable,                   
	bus_byte_enable,                  
	bus_rw,                          
	bus_write_data,                   
	bus_read_data,
	address,
	read_data,
	write_data,
	byte_en,
	wren
);

	input  wire 		  clk,
	output reg          bus_acknowledge,                  
	output wire         bus_irq,                          
	input  wire [15:0]  bus_address,                     
	input  wire         bus_bus_enable,                   
	input  wire [3:0]   bus_byte_enable,                  
	input  wire         bus_rw,                          
	input  wire [31:0]  bus_write_data,                   
	output wire [31:0]  bus_read_data,
	output reg  [31:0]  address,
	input  reg  [31:0]  read_data,
	output reg  [31:0]  write_data,
	output reg  [3:0]   byte_en,
	output wire         wren

	reg [1:0] state;
	
	assign bus_irq = 0;
	// Aligns adress on bytes and pads 0 at the begining
	assign address = {14'b0, bus_address, 2'b0};
	assign byte_en = bus_byte_enable;
	
	always @(posedge(clk)) begin
		case(state)
			`ST_IDDLE: begin
				wren <= 1'b0;
				bus_acknowledge <= 1'b0;
				if(bus_rw == 1'b0) begin
					state <= `ST_WRITE;
				end else begin
					state <= `ST_READ;
				end
			end
			
			`ST_READ: begin
				bus_acknowledge <= 1'b1;
				bus_read_data   <= read_data;
				state <= `ST_IDDLE;
			end
			
			`ST_WRITE: begin
				bus_acknowledge <= 1'b1;
				wren <= 1'b1;
				write_data <= bus_write_data;
				state <= `ST_IDDLE;
			end
			
			`ST_NONE: begin
				state <= `ST_IDDLE;
			end
		endcase
	end

endmodule 
