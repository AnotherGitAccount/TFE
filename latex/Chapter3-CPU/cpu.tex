\chapter{Beta machine and CPU design}

In this section the different modules making up the beta machine will be studied one by one, from 
their functionality to their design. Simulation results are even provided for some of them. Once the 
different elements are explained, the instruction set desired for the beta machine will be 
described. And finally, the different modules will be connected to each other to form the beta
machine with the desired instruction set.

TODO: introduire beta machine

\section{Beta machine components}

\subsection{Program counter}

The program counter is a module with seven inputs (clk, clk\_en, rst, pcsel, offset, data, pc\_in) 
and two outputs (pc\_out and pc\_next), as shown in Figure \ref{fig:components/pc}. 
Its functions are to provide the current counter on pc\_out ($PC$) and its 
next value ($PC + 4$) on pc\_next, and to react to a control signal named pcsel. This control 
will allow to choose the program counter's operating mode. The different modes and their functions
are listed in Table \ref{tab:pc/modes}. Note that if one connects pc\_new to pc\_in and that pcsel
is set to 0b00, the program counter acts like a simple 32bits 4-by-4 counter.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{Chapter3-CPU/res/pc}
    \caption{Program Counter}
    \label{fig:components/pc}
\end{figure}

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|l|l|}
    \hline
    \rowcolor[HTML]{DAE8FC} 
    \multicolumn{1}{|c|}{\cellcolor[HTML]{DAE8FC}\textbf{Mode}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{pcsel}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Details}}                                                                                                                                                                       \\ \hline
    NORMAL                                                      & 0b00                                                        & \begin{tabular}[c]{@{}l@{}}The current value of the counter program pc\_out becomes \\ the value taken from the input pc\_in.\end{tabular}                                                                                          \\ \hline
    BEQ                                                         & 0b01                                                        & \begin{tabular}[c]{@{}l@{}}The current value of the counter program pc\_out becomes \\ the value taken on the input pc\_in if the value on data is not 0. \\ Otherwise, the current value becomes pc\_in + 4 $\times$ offset.\end{tabular} \\ \hline
    JMP                                                         & 0b10                                                        & \begin{tabular}[c]{@{}l@{}}The current value of the counter program pc\_out becomes the \\ value on data.\end{tabular}                                                                                                              \\ \hline
    BNE                                                         & 0b11                                                        & \begin{tabular}[c]{@{}l@{}}The current value of the counter program pc\_out becomes\\  the value taken on the input pc\_in if the value on data is 0. \\ Otherwise, the current value becomes pc\_in + 4 $\times$ offset.\end{tabular}     \\ \hline
    \end{tabular}
    \caption{Program counter modes}
    \label{tab:pc/modes}
\end{table}

Concerning the internal circuit (that is shown in Figure \ref{fig:components/pc_in}), the pc\_out 
values will be evaluated for the different modes and 
will be put on a multiplexer which will choose the right output according to the pcsel value. For the BNE 
and BEQ modes, another multiplexer is used to make the selection between the two possible results, 
the control of these two multiplexers is naturally done by the result of $data == 0$. 

For the offset, it should be noted that it first undergoes a conversion from 16bits signed to 32bits 
signed before actually being used in the circuit.

The result selected by the multiplexer controlled by pcsel then goes to the register where it is 
stored at the next rising edge of the clock if the clk\_enable is high. The 
pc\_out will thus have the desired value and the pc\_next simply corresponds to pc\_out + 4. When 
the reset (rst) is high, the register is synchronously reset to 0.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/pc_internal}
    \caption{Program Counter internal circuit}
    \label{fig:components/pc_in}
\end{figure}

The Verilog implementation of the program counter is not a problem. Everything is relatively 
straight-forward for this module.

\subsubsection*{Program counter simulations}

The different modes of the program counter have been verified by simulation. In the first mode 
(NORMAL mode, pcsel = 0b00), it was checked that with a pc\_in at 4 294 967 292 (the maximum value with 
the last two bits at 0 that helds on 32 bits), the program counter returned 0 for pc\_next and did not 
give a random value. Other random values for pc\_in were checked to be sure that it worked 
correctly. Results of this first simulation are shown in Figure \ref{fig:sim/pc_00}. Note that the
input values are changed only once per two clock cycles but the module is totally able to manage
input changes once per cycle.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/pc_simu_00.PNG}
    \caption{Program Counter in normal mode simulations for various pc\_in values}
    \label{fig:sim/pc_00}
\end{figure}

To test the JMP mode (pcsel = 0b10), it was simply tried to set data to several values to check if 
pc\_out became this value. Results are provided in Figure \ref{fig:sim/pc_10}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/pc_simu_10.PNG}
    \caption{Program Counter in jmp mode simulations for various data values}
    \label{fig:sim/pc_10}
\end{figure}

The last simulation was for the BEQ (pcsel = 01) and BNE (pcsel = 11) modes in order to check 
different offsets (positive and negative) with data fixed at a certain value and then at 0.
Results are given in Figure \ref{fig:sim/pc_01} for BEQ and \ref{fig:sim/pc_11} for BNE.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/pc_simu_01.PNG}
    \caption{Program Counter in BEQ mode simulations for various data and offset values}
    \label{fig:sim/pc_01}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/pc_simu_11.PNG}
    \caption{Program Counter in BNE mode simulations for various data and offset values}
    \label{fig:sim/pc_11}
\end{figure}

In the different simulations the results are all valid, which adds confidence to this design before 
moving on to the practical implementation that will come later.

\subsection{ALU}

The Arithmetic Logic Unit (ALU) allows the resolution of arithmetic, logic and bit shifting 
operations. These operations are selected using the alufn signal. The chosen operation is then 
applied on the two operands data\_a and data\_b and sends the result on res. The different 
operations are listed in Table \ref{tab:alu/alufn}\footnote{unsigned(data\_b[4:0]) in the table means 
that only the five last bits of data\_b are used and that they are intepreted as an unsigned number
}and a view of the module is shown in Figure \ref{fig:components/alu}. 

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.8]{Chapter3-CPU/res/alu}
    \caption{Arithmetic Logic Unit (ALU)}
    \label{fig:components/alu}
\end{figure}

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|l|l|}
    \hline
    \rowcolor[HTML]{DAE8FC} 
    \multicolumn{1}{|c|}{\cellcolor[HTML]{DAE8FC}\textbf{Operation}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{alufn}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Result}}   \\ \hline
    No operation                                                     & 0b0000                                                      & res = 0                                                        \\ \hline
    Addition                                                         & 0b0001                                                      & res = data\_a + data\_b                                        \\ \hline
    Substraction                                                     & 0b0010                                                      & res = data\_a - data\_b                                        \\ \hline
    Multiplication                                                   & 0b0011                                                      & res = data\_a $\times$ data\_b                    \\ \hline
    No operation                                                     & 0b0100                                                      & res = 0                                                        \\ \hline
    Bitwise-and                                                      & 0b0101                                                      & res = data\_a \& data\_b                                       \\ \hline
    Bitwise-or                                                       & 0b0110                                                      & res = data\_a $|$ data\_b                                        \\ \hline
    Bitwise-xor                                                      & 0b0111                                                      & res = data\_a $\oplus$ data\_b                         \\ \hline
    Compare equal                                                    & 0b1000                                                      & res = (data\_a == data\_b) ? 1 : 0                             \\ \hline
    Compare less                                                     & 0b1001                                                      & res = (data\_a \textless data\_b) ? 1 : 0                      \\ \hline
    Compare less or equal                                            & 0b1010                                                      & res = (data\_a $\leq$ data\_b) ? 1 : 0                   \\ \hline
    Logical left shift                                               & 0b1011                                                      & res = data\_a $<<$ unsigned(data\_b[4:0])                     \\ \hline
    Logical right shift                                              & 0b1100                                                      & res = data\_a $>>$ unsigned(data\_b[4:0])               \\ \hline
    Arithmetic right shift                                           & 0b1101                                                      & res = data\_a $>>>$ unsigned(data\_b[4:0]) \\ \hline
    No operation                                                     & 0b1110                                                      & res = 0                                                        \\ \hline
    No operation                                                     & 0b1111                                                      & res = 0                                                        \\ \hline
    \end{tabular}
    \caption{ALU operations}
    \label{tab:alu/alufn}
\end{table}

Regarding the internal design of the ALU shown in Figure \ref{fig:components/alu_in}, it is very 
simple. Indeed, all the operations are executed in parallel and a multiplexer is in charge of 
selecting the result that will be transmitted to the output. This value is then recorded in the 
register on the rising edge of the clock if the clk\_en is in the high state. For the ALU, there is 
no reset, that's why the register reset is always 0.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/alu_internal}
    \caption{Arithmetic Logic Unit (ALU) internal circuit}
    \label{fig:components/alu_in}
\end{figure}


For the implementation of the ALU in Verilog, the operators are directly used in the code and the 
compiler selects the right circuits to perform them. The arithmetic operations are 
performed by DSPs while the logic operations are performed directly by logic gates. Concerning the
shifts, they are basically free on an FPGA. Indeed, shifting the 
connections of the signals is enough to achieve it, that does not pose any concern.

\subsubsection*{ALU simulations}

In order to check the behavior of the ALU, all the operations have been tested with different 
operands : the tested combinations data\_a, data\_b are listed in Table \ref{tab:alu/sim}. 
All the results obtained are correct, which validates the ALU.

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|}
    \hline
    \rowcolor[HTML]{DAE8FC} 
    \multicolumn{1}{|c|}{\cellcolor[HTML]{DAE8FC}\textbf{data\_a}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{data\_b}} \\ \hline
    800                                                            & 8                                                             \\ \hline
    0                                                              & 0                                                             \\ \hline
    0                                                              & 8                                                             \\ \hline
    8                                                              & 0                                                             \\ \hline
    -1                                                             & 8                                                             \\ \hline
    8                                                              & -1                                                            \\ \hline
    -8                                                             & 8                                                             \\ \hline
    8                                                              & -8                                                            \\ \hline
    \end{tabular}
    \caption{Operand combinations used in the ALU simulations}
    \label{tab:alu/sim}
\end{table}

The results of the simulations are shown in Figures \ref{fig:sim/alu_0} to \ref{fig:sim/alu_7}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/alu_simu_0.PNG}
    \caption{ALU simulations for alufn = 0b0000 (No operation), 0b0001 (Addition), 0b0010 (Substraction) 
    and 0b0011 (Multiplication). data\_a, data\_b and res values are shown in signed decimal 
    representation}
    \label{fig:sim/alu_0}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/alu_simu_1_0.PNG}
    \caption{ALU simulations for alufn = 0b0100 (No op) and 0b0101 (Bitwise-and). data\_a, data\_b and
    res values are shown in hexadecimal representation}
    \label{fig:sim/alu_1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/alu_simu_1_1.PNG}
    \caption{ALU simulations for alufn = 0b0110 (Bitwise-or) and 0b0111 (Bitwise-xor). data\_a, data\_b and
    res values are shown in hexadecimal representation}
    \label{fig:sim/alu_2}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/alu_simu_2.PNG}
    \caption{ALU simulations for alufn = 0b1000 (Compare equal), 0b1001 (Compare less) and
    0b1010 (Compare less equal). data\_a, data\_b and res values are shown in signed decimal 
    representation}
    \label{fig:sim/alu_3}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/alu_simu_3_0.PNG}
    \caption{ALU simulations for alufn = 0b1011 (Logical left shift). data\_a and
    res values are shown in hexadecimal representation. data\_b is shown in signed decimal 
    representation}
    \label{fig:sim/alu_4}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/alu_simu_3_1.PNG}
    \caption{ALU simulations for alufn = 0b1100 (Logical right shift). data\_a and
    res values are shown in hexadecimal representation. data\_b is shown in signed decimal 
    representation}
    \label{fig:sim/alu_5}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/alu_simu_3_2.PNG}
    \caption{ALU simulations for alufn = 0b1101 (Arithmetic right shift). data\_a and
    res values are shown in hexadecimal representation. data\_b is shown in signed decimal 
    representation}
    \label{fig:sim/alu_6}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/alu_simu_4.PNG}
    \caption{ALU simulations for alufn = 0b1110 (No operation) and 0b1111 (No operation).
     data\_a, data\_b and res values are shown in signed decimal 
    representation}
    \label{fig:sim/alu_7}
\end{figure}

\subsection{Memories, generalities}

On the Cyclone V, all memory definitions are done through the same interface: the altsyncrams. 
Whether it is for RAM, ROM, one port, two ports, two real ports (independent clocks), ... this 
module will be used. Also, both MLAB and M10K are represented by this Verilog module. 
Obviously, for all these different functions, the module must be configured. This will be done on 
the one hand by a parameterization (for example to specify the size of the memory, the size of the 
words, the choice of the type MLAB or M10K, the number of ports, of clocks, the inputs / outputs 
which are registered, if there is a clock enable or not, ...) and on the other hand by the inputs 
and outputs which are used or not (for example for the ROM all the ports linked to the writing will 
not be used and the write enable will be put at the ground, in the low state). 

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{Chapter3-CPU/res/altsyncram.PNG}
    \caption{Altsyncram - True Dual-port mode}
    \label{fig:memories/altsyncram}
\end{figure}

Fortunately for the user, all this can be done through a graphical interface: with the Megawizard, 
seen earlier in this report. This tool will therefore be used intensively for the generation of 
different memories, which will be the subject of the following sections.

\subsection{Instruction memory}

The purpose of the instruction memory is, as its name indicates, to contain instructions. These, as 
will be detailed later, are coded on 32 bits. It will thus be necessary to have words of 32bits. The 
access to the memory only needs to be done in read mode, to read the instructions, so it would be tempting 
to use a ROM. However, it is also necessary to have a write access in order to be able to modify the 
program dynamically, without having to pass by a recompilation and reprogramming of the FPGA. 
Concerning the configuration of the Altsyncram, the 
memory has only one port, the outputs are not registered in order to have the results of the reads 
and writes after one clock cycle (the inputs are obligatory registerd), only one clock is used and 
clock enable signals are added. The only thing left to do is to choose the size of the memory. For 
the instruction memory, it is set to 32 768 words (thus 32 768 operations coded on 32 bits), which 
corresponds to an address aligned on words of 15 bits. This memory described with the Megawizard 
is called ram\_32768 in the project, its ports are shown in Figure \ref{fig:components/im_in}\footnote{
The notation cpu\_address[16:2] in the figure means that bits 2 to 16 of cpu\_address are selected. 
The other bits are unused.}.

Now that the module based on the altsyncram is created, it is needed to create an interface allowing 
access from the rest of the beta machine. One also needs to add the programming ports. The
module that represents this interface is actually the Instruction memory itself, the module ports
are shown in Figure \ref{fig:components/im}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{Chapter3-CPU/res/instruction_memory}
    \caption{Instruction memory}
    \label{fig:components/im}
\end{figure}

In fact, a bit named alive allows the memory to choose between two buses, one that will be used for 
accesses from outside the CPU (from the Memory Access Unit, this will be discussed in another 
section) and one for access from the CPU. There is therefore a multiplexer on each input which will 
choose one of the two buses according to the value of alive. These signals are then redirected to 
the ram\_32768 to access the memory.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/instruction_memory_in}
    \caption{Instruction memory internal circuit}
    \label{fig:components/im_in}
\end{figure}

\subsection{Data memory}

The data memory is used to store data from the CPU, it corresponds to the main memory of the CPU.

For this memory, everything happens exactly the same as for the instruction memory. The only 
thing that changes is the size of the internal RAM. Indeed, this one is 16384 words of 32bits. This 
value has been chosen to be twice as small as the instruction memory and to fit both together in 
the FPGA (in addition to the other memories that will be seen later). The interface of this module
is displayed in Figure \ref{fig:components/dm} and its internal circuits in Figure \ref{fig:components/dm_in}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{Chapter3-CPU/res/data_memory}
    \caption{Data memory}
    \label{fig:components/dm}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/data_memory_in}
    \caption{Data memory internal circuit}
    \label{fig:components/dm_in}
\end{figure}

\subsection{Register file}

The purpose of the register file is to give access to 32 registers to the CPU. Two reads and one 
write operations must be able to be executed simultaneously by this module. A single register is not 
accessible in read mode. This is register 31. A read to this register will always results in a 0
value writen on the data\_read output.

In the register file, two memories of 32 words of 32 bits are used, this memory then represents 
the 32 registers. As the register file needs two simultaneous read and write accesses, it is
mandatory to use two separate memories because Altsyncrams do not support tri-port accesses.
By having two rams with two ports, one port of each can be used to perform mirrored writes and the 
other port is used to have a read access. This gives two independent reads and a single write. In 
fact, the memories are a copy of each other in this configuration. 

However, writing and reading are never enabled at the same time in this work (the reason is explained
later in this chapter). But 
in order to provide the correct interface for future works, the register file implements all three 
ports anyway. 

Four ports are used to control the operation of the register file. First of all, the 
two clock enable signals (cpu\_clk\_en) allow reading for cpu\_clk\_en[0] and writing for cpu\_clk\_en[1].  Then, 
a cpu\_wren signal also allows to allow writing operations or not. However, in the case where the writes and 
reads of the register file are executed in two different steps, cpu\_wren and cpu\_clk\_en[1] must be in the 
high state for a write to take place. In case a user would like to use all the ports simulataneously, 
it would be required to set both cpu\_clk\_en signals to the high state. In this configuration, writing 
is then totally controlled by the cpu\_wren signal. Finally, the alive signal allows, as for the instruction and 
data memories, to make the register file listen to the CPU or MAU buses. The different ports of the register file 
are shown in Figure \ref{fig:components/rf}.

For access from the MAU, the register file exposes only one port which will be used either for 
reading or writing (depending on the state of mau\_wren). That is why the mau bus only hava one 
address signal, a read signal and a write signal. When writing, the value is stored on 
both memories, while reading only operates on one memory.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{Chapter3-CPU/res/reg_file}
    \caption{Register file}
    \label{fig:components/rf}
\end{figure}

As shown in Figure \ref{fig:components/rf_in}, although two memories are now present, the internal 
circuit remains very similar to that of the memories previously seen. The notable differences are at 
the level of the cpu\_clk\_en and of the cpu\_wren where the two clock enable signals 
must now be managed. At the output, a multiplexer is positioned on each of the two data-read signals in 
order to make a selection between the value in memory and 0. The value 0 is put on the output when 
the input address points to register 31.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Chapter3-CPU/res/reg_file_in}
    \caption{Register file internal circuit}
    \label{fig:components/rf_in}
\end{figure}

\subsection{Control logic}

The control logic is the core element of the cpu. Its purpose is to convert the opcode of an 
instruction into a set of control signals that adequately configure the different modules of 
the system so that the instruction executes properly. The control logic used in this work is simply a 
ROM (thus an Altsyncram configured in read-only mode) whose address is the opcode. The read value 
contains all control bits. As will be seen in the following section, the opcodes of the Beta 
machine are represented on 6 bits. The addressing of the control logic is therefore done on 6 bits. 
The words contained in the memory are represented on 12 bits.

The ROMs can be written at the compilation of the project on Quartus. This is done by associating a
hexadecimal file (.hex) to the ROM. The configuration of this file and the meaning of the different 
bits of the words in this memory are explained later in the report. 

This module being a wrapper of the Altsyncram configured in ROM, only the interface of this 
module is given, in Figure \ref{fig:components/cl}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{Chapter3-CPU/res/control_logic}
    \caption{Control logic}
    \label{fig:components/cl}
\end{figure}

\section{Instruction Set Architecture}
\subsection{Instructions formats}

Two instruction formats are used in the instruction set, the first one is used for all instructions 
requiring two operands ($R_a$ and $R_b$ in Figure \ref{fig:instructions/format}) which will be for example 
the case for simple arithmetic instructions. The second format is used for all instructions 
requiring a single operand and a constant. This will be the case for example for conditional jump 
operations. As can be seen in Figure \ref{fig:instructions/format}, the $R_x$ contain register 
addresses. As they are on 5 bits and no bank change operation exists, 32 registers are addressable. 
$R_c$ stores the result of the instruction when a result exists. It should be noted that the 
constants are on 16 bits and signed. In Figure \ref{fig:memories/altsyncram} the most general interface 
with two true ports is shown. 

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{Chapter3-CPU/res/instruction}
    \caption{Instructions format}
    \label{fig:instructions/format}
\end{figure}

\subsection{Instruction set}

\subsubsection*{Arithmetic and logic instructions}

The different arithmetic and logic instructions are managed by the Arithmetic Logic Unit (ALU). The 
different instructions listed in Table \ref{tab:instruction/alu} are supported.

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|l|}
    \hline
    \rowcolor[HTML]{DAE8FC} 
    \multicolumn{1}{|c|}{\cellcolor[HTML]{DAE8FC}\textbf{Name}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Operation}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Opcode}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Const Operation}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Const Opcode}} \\ \hline
    Addition                                                    & ADD                                                             & 0x20                                                         & ADDC                                                                  & 0x30                                                               \\ \hline
    Substraction                                                & SUB                                                             & 0x21                                                         & SUBC                                                                  & 0x31                                                               \\ \hline
    Multiplication                                              & MUL                                                             & 0x22                                                         & MULC                                                                  & 0x32                                                               \\ \hline
    Bitwise and                                                 & AND                                                             & 0x28                                                         & ANDC                                                                  & 0x38                                                               \\ \hline
    Bitwise or                                                  & OR                                                              & 0x29                                                         & ORC                                                                   & 0x39                                                               \\ \hline
    Bitwise xor                                                 & XOR                                                             & 0x2A                                                         & XORC                                                                  & 0x3A                                                               \\ \hline
    Compare equal                                               & CMPEQ                                                           & 0x24                                                         & CMPEQC                                                                & 0x3A                                                               \\ \hline
    Compare less                                                & CMPLT                                                           & 0x25                                                         & CMPLTC                                                                & 0x35                                                               \\ \hline
    Compare less or equal                                       & CMPLE                                                           & 0x26                                                         & CMPLEC                                                                & 0x36                                                               \\ \hline
    Logical left shift                                          & SHL                                                             & 0x2C                                                         & SHLC                                                                  & 0x3C                                                               \\ \hline
    Logical right shift                                         & SHR                                                             & 0x2D                                                         & SHRC                                                                  & 0x3D                                                               \\ \hline
    Arithmetic rifht shift                                      & SRA                                                             & 0x2E                                                         & SRAC                                                                  & 0x3E                                                               \\ \hline
    \end{tabular}
    \caption{Arithmetic and logic instructions}
    \label{tab:instruction/alu}
\end{table}

All these instructions simply perform the operation associated with them on the operands $R_a$ and 
$R_b$ in the normal case and on the operands $R_a$ and the constant in the case of instructions 
with constants. $R_a$ will always be used as the first operand. For example, the instruction given 
in Figure \ref{fig:instructions/subc} will result in $[R_{10}] = [R_{14}] - 17$. The notation 
$[R_x]$ means the content of register $R_x$.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{Chapter3-CPU/res/instruction_subc}
    \caption{SUBC instruction example}
    \label{fig:instructions/subc}
\end{figure}

Concerning the comparison operations, they will simply put a $0$ in $R_c$ when the comparison is 
false, a $1$ otherwise.

\subsubsection*{Program counter instructions}

The purpose of these instructions is to modify the value of the program counter conditionally or 
not. The different instructions are listed in Table \ref{tab:instruction/pc}. The values of 
column Next PC will be writen to PC and the address of the next instruction before the jump is
stored in Rc. Note that [Ra] should be byte aligned for JMP but the constant should be 32bits 
aligned for BEQ and BNE (as they already multiply the constant by 4).

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|l|}
    \hline
    \rowcolor[HTML]{DAE8FC} 
    \multicolumn{1}{|c|}{\cellcolor[HTML]{DAE8FC}\textbf{Name}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Operation}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Opcode}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Condition}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Next PC}} \\ \hline
    Jump                                                        & JMP                                                             & 0x1B                                                         & None                                                                 & {[}Ra{]} \& 0xFFFFFFC                                         \\ \hline
    Branch Equal                                                & BEQ                                                             & 0x1D                                                         & {[}Ra{]} == 0                                                        & PC + 4 $\times$ (Constant + 1)             \\ \hline
    Branch Not Equal                                            & BNE                                                             & 0x1E                                                         & {[}Ra{]} != 0                                                        & PC + 4 $\times$ (Constant + 1)                \\ \hline
    \end{tabular}
    \caption{Program counter instructions}
    \label{tab:instruction/pc}
\end{table}

\subsubsection*{Memory instructions}

Here, only two instructions are present. One is to load a value from the data memory and the other 
is to store a value in it. The notation $<x>$ means at address $x$ in memory. Note that here $R_c$
doesn't necessarily contains a result at the end of an operation and is used as an operand for ST.
Also, addresses must be byte aligned here and offsets contained in Constant must also be byte
aligned. Both instructions are detailed in Table \ref{tab:instruction/dm}.

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    \rowcolor[HTML]{DAE8FC} 
    \multicolumn{1}{|c|}{\cellcolor[HTML]{DAE8FC}\textbf{Name}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Operation}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Opcode}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Action}} \\ \hline
    Load                                                        & LD                                                              & 0x18                                                         & {[}Rc{]} = $<${[}Ra{]} + Constant$>$      \\ \hline
    Store                                                       & ST                                                              & 0x19                                                         & $<${[}Ra{]} + Constant$>$ = {[}Rc{]}        \\ \hline
    \end{tabular}
    \caption{Memory instructions}
    \label{tab:instruction/dm}
\end{table}

\subsubsection*{Control instructions}

Only one control instruction exists. This instruction bascally stops the machine and has no operand
or result. The instruction is detailed in Table \ref{tab:instruction/ctrl}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|}
    \hline
    \rowcolor[HTML]{DAE8FC} 
    \multicolumn{1}{|c|}{\cellcolor[HTML]{DAE8FC}\textbf{Name}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Operation}} & \multicolumn{1}{c|}{\cellcolor[HTML]{DAE8FC}\textbf{Opcode}} \\ \hline
    Exit                                                        & EXIT                                                            & 0x3F                                                         \\ \hline
    \end{tabular}
    \caption{Exit instruction}
    \label{tab:instruction/ctrl}
\end{table}

\section{Beta machine}
