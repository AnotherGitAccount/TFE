\chapter{Memory Access Unit and Control Unit design}

This section describes the Memory Access Unit, which gives the ARM part read and write 
access to several memories of the system. Another super-unit, the Control Unit is also described here. 
The latter keeps the state of the machine (on or off) and gives access to this register to the 
ARM part. The ARM processor can therefore switch the machine on and off as it wishes from this 
access. Before introducing these two super-units, the Avalon protocol is first described. This 
protocol allows the communications through the bridges existing between the ARM and FPGA parts of
the Cyclone V.

\section{Communication between ARM and FPGA sides}

The communication between the two parts takes place via one of the previously mentioned bridges using 
the Avalon protocol described by Intel. This protocol allows 
high-speed communication. The Avalon interface has different sub-interfaces for different types 
of communication. Each type is adapted to certain applications. In this project where the protocol 
is used to communicate between master and slave devices, the Avalon MM is used. 
The Avalon MM protocol is address-based which is very suitable for the needs of this project.
We here describe the read and write operations of this protocol.

\subsection{Read operation}

The sequence diagram of the protocol for the reading operation is 
visible in Figure \ref{fig:avalon/mm_read}. In the diagram, two masters are represented but only 
the unique master case is described. In the first place, the master simply has to give
the start address to which it wants to read, the length of the burst (the number of words desired).  It also has to switch the read and beginbursttransfer signals to high.  The slave then responds 
to this with a waitrequest that goes up. The master must imperatively keep all signals unchanged --- except 
beginbursttransfer which returns to the low state --- during the waitrequest to give the 
slave time to capture them. Once ready, the slave removes the waitrequest and informs that  
data is available by switching readdatavalid to high and sending the first word. The other words 
are then sent to the master in the order of their addresses. 

\begin{figure}[ht!]
  \center
  \includegraphics[width=\linewidth]{"Chapter5-MAU_CTRLU/res/avalon_mm_read.png"}
  \caption{Read operation using Avalon MM}
  \label{fig:avalon/mm_read}
\end{figure}

\subsection{Write operation}

For writing, it's even simpler. As can be seen in Figure \ref{fig:avalon/mm_write}, the beginning 
is similar to reading. The master has to provide the first address, the length of the 
burst and also to switch beginbursttransfer to high. In addition to that, the first word 
is also provided. Here again, the slave responds with a waitrequest. As soon as the waitrequest 
is switched off, the master sets the beginbursttransfer to low and sends the words one after the other, 
starting at the next clock cycle. If the write signal goes down, the burst is paused and resumes 
as soon as it goes up again.

\begin{figure}[ht!]
  \center
  \includegraphics[width=\linewidth]{"Chapter5-MAU_CTRLU/res/avalon_mm_write.png"}
  \caption{Write operation using Avalon MM}
  \label{fig:avalon/mm_write}
\end{figure}

This protocol is not very complicated. However, it has a lot of signals and is not necessarily 
practical to use directly in user-developed slaves and masters. This is why interface modules are 
used. These modules are described in the sections where they are needed.

\section{Memory Access Unit (MAU)}

Like previously mentioned several times the MAU allows access to several memories of the machine. In order 
to simplify the protocol in the machine, a module called Avalon to External Bus Bridge is used. This 
module manages the Avalon protocol and exposes an interface (the external bus) using a simpler 
protocol. This module is used as many times as there are memories to connect to the interconnect.
The various signals used by this module are shown in Figure \ref{fig:mau/bus_bridge}. Note that this
module has an integrated timer that is reset each time the Avalon to external bus bridge receives
an acknowledgement from the external slave. When this timer reaches 0, the request from the master 
(denoted by Avalon Switch Fabric in Figure \ref{fig:mau/bus_bridge}) is deleted.

\begin{figure}[ht!]
    \center
    \includegraphics[scale=0.8]{"Chapter5-MAU_CTRLU/res/external_bus_bridge.PNG"}
    \caption{Avalon to external bus bridge interface and signals}
    \label{fig:mau/bus_bridge}
\end{figure}

The protocol is considered simpler because it offers an interface closer to that used by the memories 
than that of the Avalon.
% PF above sentence is heavy, try to simplify and make clearer
Indeed, the usual signals address, write data, read data and R$\overline{W}$ are 
present. Moreover, this protocol is very simple to use. Indeed, as can be seen in Figure \ref{fig:mau/bus_bridge_protocol}. The master 
places all the necessary elements on the bus and then switches the bus enable signal to high. This means 
that the slave can act. The slave then does what it has to do. Either take the data and write it to 
the address given by the master or send the requested data that is present at the address given by 
the master. Once the slave has finished its job, it switches the acknowledgement signal to high 
during a clock cycle to validate the transaction. 

\begin{figure}[ht!]
    \center
    \includegraphics[scale=0.8]{"Chapter5-MAU_CTRLU/res/external_bus_timings.PNG"}
    \caption{External bus protocol timings}
    \label{fig:mau/bus_bridge_protocol}
\end{figure}

It is possible to configure the address range and the word size used by these bus. For this work, 
it is decided that the 
addressable space is 256 Kbytes long and that the words are on 32 bits for each access except for the 
access to the GPU mask memory which is on 4 Kbytes with 128 bits words. Each of these accesses are 
put on the HPS-FPGA bridge, their offset is given in Table \ref{mau/bus}. These dimensions were 
chosen to make the offset easy to remember. Indeed, only the sixth number changes in the 
hexadecimal address. Moreover, this gives future users a large margin if they want to change the 
dimensions of the memories. As far as the mask memory is concerned, the address range is simply the 
size of the memory. This has been done especially to discourage any modification at this level. 
Indeed, this would lead to a large modification of the GPU which could degrade its performance or 
make it impossible to include in the design (due to lack of space on the FPGA). More over, the size
of this memory is already the maximum addressable size possible for the store operation, using the
GPU format.

\begin{table}[ht!]
    \centering
    \begin{tabular}{|l|c|c|c|c|}
    \hline
    \rowcolor[HTML]{DAE8FC} 
    \multicolumn{1}{|c|}{\cellcolor[HTML]{DAE8FC}\textbf{Access}} & \textbf{Base} & \textbf{End} & \textbf{Address range} & \textbf{Word size} \\ \hline
    Instruction Memory (CPU)                                      & 0x0000 0000   & 0x0003 FFFF  & 256kB             & 32                 \\ \hline
    Data Memory (CPU)                                             & 0x0010 0000   & 0x0013 FFFF  & 256kB             & 32                 \\ \hline
    Register File (CPU)                                           & 0x0020 0000   & 0x0023 FFFF  & 256kB             & 32                 \\ \hline
    I/Os (IOU)                                                    & 0x0030 0000   & 0x0033 FFFF  & 256kB             & 32                 \\ \hline
    Mask Memory (GPU)                                             & 0x0040 0000   & 0x0040 0FFF  & 4096B             & 128                \\ \hline
    \end{tabular}
    \caption{Memory bus description}
    \label{mau/bus}
\end{table}

The connections in QSys are shown in Figure \ref{fig:avalon/bus}. 
The different modules and the HPS are highlighted in 
yellow. The different Avalon slaves and the master are shown in red. It can be noticed by following 
the connection highlighted in blue that it is indeed the HPS-FPGA bridge that is used 
(h2f\_axi\_master in Qsys) and that the offsets of the slaves are indeed those previously given. The 
signals corresponding to the buses are displayed in green. Each of them is exported, that is to say 
that they can be used from the FPGA. They are the ones that are connected to the different memories.

\begin{figure}[ht!]
    \center
    \includegraphics[width=\linewidth]{"Chapter5-MAU_CTRLU/res/qsys_mau.PNG"}
    \caption{Avalon to external bus bridges connections in Qsys}
    \label{fig:avalon/bus}
\end{figure}

Now that the descriptions of the external bus bridge and its implementation are done, the design of 
the MAU can be considered.

\subsection{Memory Access}

In fact, the Memory Access Unit is composed of only two types of modules. The Memory Access 32, and 
the Memory Access 128 both allowing the interfacing between an external bus and a memory (these two
modules respectively manage words of 32 and 128 bits). To do this, they both implement a finite state machine. 
That of Memory Access 32 is given in Figure \ref{fig:ma_fsm}. The only difference that the 128 bits version 
has is that the address is not multiplied by 4 in the Idle state. 

\begin{figure}[ht!]
    \center
    \includegraphics[scale=0.8]{"Chapter5-MAU_CTRLU/res/mau_fsm"}
    \caption{Memory Access 32 finite state machine}
    \label{fig:ma_fsm}
\end{figure}
% PF : change Iddle to Idle in the fsm above

This state machine simply follows the protocol described earlier. It only acts when the bus is high 
and sends an acknowledge during a clock cycle once the request is executed (the finite state machine 
is reevaluated at each clock cycle). On the read side, a state seems to be useless (Read 1). This 
one is in fact very important, it gives the memory time to fetch the value present at the requested 
address. The interfaces of the memory access are given in Figures \ref{fig:ma32} and \ref{fig:ma128}.

\begin{figure}[ht!]
    \center
    \includegraphics[scale=0.8]{"Chapter5-MAU_CTRLU/res/memory_access_32"}
    \caption{Memory Access 32}
    \label{fig:ma32}
\end{figure}

\begin{figure}[ht!]
    \center
    \includegraphics[scale=0.8]{"Chapter5-MAU_CTRLU/res/memory_access_128"}
    \caption{Memory Access 128}
    \label{fig:ma128}
\end{figure}

\subsection{Memory Access Unit circuit}

The Memory Access Unit is therefore a simple parallelization of four Memory Access 32 modules and 
one Memory Access 128 module. The MAU is later connected to the different signals exported in 
QSys. The circuit of the MAU is given in Figure \ref{fig:mau_in} and its interface is shown in 
Figure \ref{fig:mau}. In order to simplify the interface of the MAU, not all signals are put in it 
and a bus representation is used. However, all signals are shown in the internal circuit.

\begin{figure}[ht!]
    \center
    \includegraphics[width=\linewidth]{"Chapter5-MAU_CTRLU/res/mau_in"}
    \caption{Memory Access Unit internal circuit}
    \label{fig:mau_in}
\end{figure}

\begin{figure}[ht!]
    \center
    \includegraphics[scale=0.8]{"Chapter5-MAU_CTRLU/res/mau"}
    \caption{Memory Access Unit}
    \label{fig:mau}
\end{figure}

\section{Control Unit (CTRLU)}

The control unit is a very simple unit. It manages the state of the machine. This means that 
it decides whether the machine is switched on or off. Initially, the machine is switched off (alive 
is in the low state). When alive is low, the memories of the machine can be manipulated by the ARM 
processor. It is thus at this moment that the machine is programmed. Once this is done, the ARM 
processor can start the machine by switching alive to the high state, the means by which this is 
achieved are seen just after. During the execution of a program, it can be stopped in two ways. 
First, the ARM processor can stop it by passing alive to the low state. Second, 
the beta machine itself can order the stop by executing the EXIT instruction which changes the 
halt signal to high. The control unit then responds to this signal by switching alive to low.

As for the MAU, it is necessary to connect a module to the interconnect to make this unit 
accessible from the ARM processor. Once again, the Avalon protocol is not used directly. 
Instead, a module called Parallel IO (PIO) is used. This one gives direct access to a register 
from the interconnect (and thus from the ARM processor). This module also uses Avalon MM, so 
the register has an address from the point of view of the ARM processor. A difference with 
the Avalon to external bus bridge of the MAU is that the PIO is put on the lightweight HPS-FPGA 
bridge. This choice is made because the PIO is not frequently used and does not require large data 
transfers. For this kind of modules, the HPS documentation advises to use the lightweight bridge.
The connection of the parallel IO in QSys is shown in Figure \ref{fig:qsys/ctrlu}. The usual color code is used.

\begin{figure}[ht!]
    \center
    \includegraphics[width=\linewidth]{"Chapter5-MAU_CTRLU/res/qsys_ctrlu.PNG"}
    \caption{Parallel IO connections in QSys}
    \label{fig:qsys/ctrlu}
\end{figure}

One of the ports is exported. In fact this one exposes two signals. One input and one output. The 
output allows to read what the ARM processor proposes as new value of the register while the input 
allows to set the value of the register. A module must therefore be added between the input and the 
output in order to listen to the ARM processor port and the beta machine port and to set the 
register accordingly. This module is in fact the control unit itself.

\subsection{Control Unit circuit}

The Control Unit, like the memory access, simply implements a finite state machine. This one is 
described in Figure \ref{fig:ctrlu/fsm}. The hps\_cmd signal represents the signal coming from the 
PIO (thus from the HPS) and the halt is the stop signal of the beta machine. According to these 
signals, the value of alive is fixed. The on/off transitions initiated by the ARM processor are 
done in two steps. A transition is completed when the ARM processor sends a 1 followed by a 0. This 
has been done as so to have only one bit for the command. If the change of state was done directly 
when a 1 appeared, the final state would have been uncertain. Indeed, it is impossible to know for 
how many clock cycles the 1 is maintained by the ARM. Depending on the number of cycles it would 
take to reset its signal to 0, the state would switch several times between on and off. With 
the intermediate state, any bounce between states is avoided. Furthermore, simply using 1 for alive and 0 for
stop is not a good idea either since the ARM processor would have to always listen to state changes
coming from the beta machine to ensure that theirs values are coherent.

\begin{figure}[ht!]
    \center
    \includegraphics[scale=0.8]{"Chapter5-MAU_CTRLU/res/ctrlu_fsm"}
    \caption{Finite state machine of the Control Unit}
    \label{fig:ctrlu/fsm}
\end{figure}

The control unit then exposes its state and the alive signal. The two bits of the state are passed 
into a logic AND gate whose two inputs are inverted and the output of this gate is used to set the 
PIO register (the corresponding circuit is shown when the entire system is connected later in this 
report). The PIO register is  therefore high when the machine is stopped and low at any other time. 
This is done because when the register goes from low to high, an interrupt is sent to the ARM 
processor. Since it is interesting to receive the interrupt when the machine is shut down, it has been 
done this way. However, this interrupt is not used in this work but it could trigger an interaction between the ARM processor and beta machine. 
A visual summary is displayed in Figure \ref{fig:ctrlu/summary} and the interface of the Control 
Unit is therefore the one given in Figure \ref{fig:ctrlu}.

\begin{figure}[ht!]
    \center
    \includegraphics[scale=0.8]{"Chapter5-MAU_CTRLU/res/ctrlu_summary"}
    \caption{ARM, Beta Machine and CTRLU interaction summary}
    \label{fig:ctrlu/summary}
\end{figure}

\begin{figure}[ht!]
    \center
    \includegraphics[scale=0.8]{"Chapter5-MAU_CTRLU/res/ctrlu"}
    \caption{Control Unit}
    \label{fig:ctrlu}
\end{figure}
